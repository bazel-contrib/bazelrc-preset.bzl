"""Rule/Macro pair to produce bazelrc preset file"""

load("@aspect_bazel_lib//lib:utils.bzl", "propagate_common_rule_attributes")
load("@aspect_bazel_lib//lib:write_source_files.bzl", "write_source_file")
load("@bazel_features_version//:version.bzl", "version")
load("@bazel_skylib//lib:new_sets.bzl", "sets")
load("//:flags.bzl", "FLAGS", "MIGRATIONS")
load("//private:util.bzl", "lt")

def _format_comment_line(s):
    s = s.strip()
    if s:
        return "# " + s
    return "#"  # Avoid trailing whitespace

def _format_flag(flag, meta):
    command = getattr(meta, "command", "common")
    commands = _expand_commands(command)

    return "\n".join(["{} {}".format(
        command,
        _format_boolean_flag(flag, meta) if type(meta.default) == "bool" else _format_flag_with_value(flag, meta),
    ) for command in commands])

def _expand_commands(command):
    if lt("6.3.0"):
        if command == "common":
            return ["build", "fetch", "query"]
        if command.startswith("common:"):
            config = command.split(":")[1]
            return ["build:{}".format(config), "fetch:{}".format(config), "query:{}".format(config)]
    return [command]

def _format_flag_with_value(flag, meta):
    return "--{}={}".format(
        flag,
        "\"{}\"".format(meta.default) if type(meta.default) == "string" else meta.default,
    )

def _format_boolean_flag(flag, meta):
    return "--{}".format(flag) if meta.default else "--no{}".format(flag)

def _generate_preset_flag(content, flag, meta):
    if not getattr(meta, "if_bazel_version", True):
        return None  # Flag does not apply to the version of Bazel currently running
    content.add("")
    content.add_all(meta.description.strip().split("\n"), map_each = _format_comment_line)
    content.add(_format_flag(flag, meta))
    return content

def _verify_command_overrides(meta):
    unique_commands = sets.make([getattr(meta_item, "command", "common") for meta_item in meta])
    if sets.length(unique_commands) != len(meta):
        fail("Multiple flag overrides use the same command. Make sure flag overrides use different command.")

def _generate_preset(ctx):
    content = ctx.actions.args().set_param_file_format("multiline")
    content.add_all([
        "Generated by bazelrc-preset.bzl",
        "To update this file, run:",
        "  bazel run {}.update".format(ctx.label),
    ], format_each = "# %s")

    flags = FLAGS | (MIGRATIONS if ctx.attr.strict else {})
    for flag, meta in flags.items():
        # Syntax sugar: allow a struct to stand in for a singleton list
        if type(meta) != type([]):
            meta = [meta]
        _verify_command_overrides(meta)
        for meta_item in meta:
            content_with_flag = _generate_preset_flag(content, flag, meta_item)
            if content_with_flag:
                content = content_with_flag
                content.add("# Docs: https://registry.build/flag/bazel@{}?filter={}".format(version, flag))
    ctx.actions.write(ctx.outputs.out, content)

generate_preset = rule(
    implementation = _generate_preset,
    attrs = {
        "out": attr.output(),
        "strict": attr.bool(
            default = False,
            doc = """\
            Whether to generate a strict preset, which includes all flags that are marked as "strict" in the registry.
            Unlike the "strict" flag in bazelisk, this applies flags being flipped in the upcoming major release.
            """,
        ),
    },
)

def bazelrc_preset(name, out_file = None, **kwargs):
    """
    Creates a bazelrc preset file.

    Args:
        name: The name of the preset.
        out_file: The file to write the preset to. If not provided, the preset will be written to `{name}.bazelrc`.
        **kwargs: Additional named arguments to pass to the `generate_preset` rule.
            Common attributes (those in https://bazel.build/reference/be/common-definitions#common-attributes)
            are propagated to the generated `write_source_file` rule as well.
    """
    if lt("6.0.0"):
        fail("bazelrc_preset requires Bazel 6 or later. You are running Bazel {}".format(version))

    generate_preset(
        name = name,
        out = "_{}.bazelrc".format(name),
        # If strict was included in kwargs, use it. Otherwise, use the value from the flag.
        strict = kwargs.pop("strict", select({
            Label("//:strict.true"): True,
            "//conditions:default": False,
        })),
        **kwargs
    )
    if not out_file:
        out_file = "{}.bazelrc".format(name)
    write_source_file(
        name = "{}.update".format(name),
        out_file = out_file,
        in_file = name,
        diff_test_failure_message = "The bazelrc preset has changed. Run 'bazel run {{TARGET}}' to update it.",
        file_missing_failure_message = "File %s is missing. Run 'bazel run {{TARGET}}' to create it." % out_file,
        **propagate_common_rule_attributes(kwargs)
    )
